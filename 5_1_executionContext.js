// 콜 스택 - 함수를 호출할 때 해당 함수의 호출 정보(함수 내 지역 변수, 인자 값 등)가 차곡차곡 쌓여있는 스텍

// ECMAScript 에서는 실행 컨텍스트를 "실행 가능한 코드르 형상화하고 구분하는 추상적인 개념" 으로 기술
// 콜 스택과 연관 지으면 실행 가능한 자바스크립트 코드 블록이 실행되는 환경이며, 이 컨텍스트 안에 실행에 필요한 여러 가지 정보를 담고 있다.
// 여기서 코드 블록은 대부분 함수.

// ECMAScript 에서 규정한 실행 컨텍스트가 형성되는 경우
// 1. 전역 코드
// 2. eval() 함수로 실행되는 경우
// 3. 함수 안의 코드를 실행할 경우

// ECMAScript에서 설명하는 실행 컨텍스트 생성
// 현재 실행되는 컨텍스트에서 이 컨텍스트와 관련 없는 실행 코드가 실행되면, 새로운 컨텍스트가 생성되어 스택에 들어가고 제어권이 그 컨텍스트로 이동한다.

console.log(`#### 1`);
console.log(`This is global context`);

function ExContext1() {
  console.log(`This is 1`);
}

function ExContext2() {
  ExContext1();
  console.log(`This is 2`);
}

ExContext2();

// 활성 객체와 변수 객체
// 스코프 체인

console.log(`#### 2`);
// 1. 활성 객체 생성
// 실행 컨텍스트가 생성되면 자바스크립트 엔진은 해당 컨텍스트에서 실행에 필요한 여러 가지 정보를 담을 객체를 생성한다.
// 이를 활성 객체라고 한다.
// 이 객체에 앞으로 사용하게 될 매개변수나 사용자가 정의한 변수 및 객체를 저장하고, 새로 만들어진 컨텍스트로 접근 가능하게 돼 있다.
// 위 말은 엔진 내부에서 접근할 수 있다는 것이지 사용자가 접근할 수 있다는 것은 아니다.
function execute(param1, param2) {
  // 2. arguments 객체 생성
  // 다음 단계에서는 arguments객체를 생성한다.
  // arguments 객체는 함수를 호출할 때 넘긴 인자들이 유사 배열 형태로 저장된 객체이다.
  // 1번의 활성 객체는 arguments프로퍼티로 이 arguments객체를 참조한다.

  // 3. 스코프 정보 생성
  // 현재 컨텍스트의 유효 범위를 나타내는 스코프 정보를 생성한다.
  // 이 스코퍼 정보는 현재 실행 중인 실행 컨텍스트 안에서 연결 리스트와 유사한 형식으로 만들어진다.
  // 현재 컨텍스트에서 특정 변수에 접근해야 할 경우, 이 리스트를 활용한다.
  // 이 리스트로 현재 컨텍스트의 변수뿐 아니라, 상위 실행 컨텍스트의 변수도 접근이 가능하다.
  // 이 리스트에서 찾지 못한 변수는 정의되지 않은 변수로 판단하여 에러를 검출한다.
  // 이 리스트를 스코프 체인이라 하며 [[scope]] 프로퍼티로 참조된다.

  console.log(a); // undefined
  // console.log(c); // error
  console.log(arguments);
  var a=1, b=2;
  function func() {
    return a+b;
  }
  // 4. 변수 생성
  // 현재 실행 컨텍스트 내부에서 사용되느 지역 변수의 생성이 이루어진다.
  // ECMAScript 에서는 생성되는 변수를 저장하는 변수 객체를 언급하는데, 실제적으로 앞서 생성된 활성 객체가 변수 객체로 사용된다.
  // 문서를 보면 어떤 곳에서는 활성 객체, 어떤 곳에서는 변수 객체라고 사용되는데 혼란스러워 하지 말자.
  // 변수 객체 안에서 호출된 함수 인자는 각각의 프로퍼티가 만들어지고 그 값이 할당된다.
  // 만약 값이 넘겨지지 않았다면 undefined가 할당된다.
  // execute() 함수 안에 정의된 변수 a, b와 함수 func가 생성된다.
  // 주의할 점은 이 과정에서는 변수나 내부 함수를 단지 메모리에 생성하고, 
  // 초기화는 각 변수나 함수에 해당하는 표현식이 실행되기 전까지는 이뤄지지 않는다.
  // 즉 변수 a, b에 먼저 undefined가 할당되고 표현식의 실행은 변수 객체 생성이 다 이뤄진 후 시작된다.
  // [ 예제 코드 ]
  // sayAAA(); // (3)
  // sayBBB(); // (5) 여기서 대입되기 전에 호출해서 에러
  // var sayBBB = function() { // (1) 선언 (6) 대입
  //   console.log('bbb');
  // }
  // function sayAAA() { // (2) 선언과 동시에 초기화(호이스팅)
  //   console.log('aaa'); // (4)
  // }

  return param1 + param2 + func();
}
// 5. this 바인딩
// 마지막 단계에서는 this 키워드를 사용하는 값이 할당된다.
// 여기선 this가 참조하는 객체가 없으므로 전역 객체를 참조한다.

console.log(`excute : ${execute(3, 4)}`);
  
// 6. 코드 실행
// 이렇게 하나의 실행 컨텍스트가 생성되고, 변수 객체가 만들어진 후에, 코드에 있는 여러 가지 표현식 실행이 이뤄진다.
// undefined가 할당된 변수 a와 b에도 이 과정에서 1, 2의 값이 할당된다.

// 전역 실행 컨텍스트는 일반적인 실행 컨텍스트와는 약간 다른데, 
// arguments 객체가 없으며, 전역 객체 하나만을 포함하는 스코프 체인이 있다.
// ECMAScript에서 언급한 바에 의하면 실행 컨텍스트가 형성되는 세 가지 중 하나로서 전역 코드가 있는데,
// 이 전역 코드가 실행될 때 생성되는 컨텍스트가 전역 실행 컨텍스트다.
// 전역 컨텍스트는 변수를 초기화하고 이것의 내부 함수는 일반적인 탑 레벨의 함수로 선언된다.
// 또한 전역 실행 컨텍스트의 변수 객체가 전역 객체로 사용된다.
// 즉, 전역 실행 컨텍스트에서 변수 객체가 곧 전역 객체이다.
// 전역적으로 선언된 함수와 변수가 전역 객체의 프로퍼티가 된다.
// 전역 실행 컨텍스트 역시 this를 전역 객체의 참조로 사용한다.

// @ 브라우저에서는 최상위 코드가 곧 전역 코드지만, Node.js에서는 다르다.
// var a = 10;
// b = 20;
// console.log(window.a); // 10
// console.log(window.b); // 20
// 브라우저에서 위 코드는 잘 실행된다. 
// var a 로 정의한 변수가 전역 객체인 window의 한 프로퍼티로 들어갔다.

var c= 10;
d  = 20;

console.log(global.c); // undefined
console.log(global.d); // 15 
// Node.js 에서는 최상위 코드가 브라우저와는 달리 전역 코드가 아니다.
// 따라서 var a로 정의된 변수가 전역 객체가 들어가지 않는다.
// Node.js에서는 일반적으로 자바스크립트 파일이 하나의 모듈로 동작하고 이 파일의 최상위에 변수를 선언해도 그 모듈의 지역 변수가 된다.
// 하지만 var를 사용하지 않을 경우 전역 객체인 global에 들어가고, 전역 객체를 오염시킬수 있다.
