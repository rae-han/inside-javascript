/**
 * # 함수 정의
 *  * 자바스크립트에서 함수를 생성하는 방법은 3가지인데 각각의 방식에 따라 함수 동작이 미묘하게 다르다.
 *    + 함수 선언문
 *    + 함수 표현식
 *    + Function() 생성자 함수 
 */

/**
 *  * 함수 리터럴
 *    + 함수도 일반 객체처럼 값으로 취급 된다.
 *    + 때문에 객체 리터럴 방식으로 일반 객체를 생성할 수 있는 것처럼, 함수 리터럴을 이용해 함수를 생성할 수 있다.
 *    + 실제로 함수 선언문, 함수 표현식 방법 모두 함수 리터럴 방식으로 함수를 생성한다.
 */

function add1 (x, y) { // 순서대로 function 키워드, 함수명, 매개변수 리스트, 함수 몸체로 구성
  return x+y;
}

/**
 *  * 함수 선언문
 *    + 함수 선언문 방식은 함수 리터럴 형태와 같다.
 *    + 함수 선언문 방식으로 정의된 함수의 경우 반드시 함수명이 정의되어 있어야 한다.
 */

function add2 (x, y) {
  return x+y;
}
console.log(add2(3, 4));

/**
 *  * 함수 표현식
 *    + 자바스크립트에서는 함수도 하나의 값처럼 취급된다.
 *    + 즉 함수도 숫자나 문자열처럼 변수에 할당하는 것이 가능핟.
 *    + 이런 방식으로 함수 리터럴로 함수를 만들고(익명 함수도 가능) 변수에 할당하여 함수를 생성하는 것을 함수 표현식이라 한다.
 */

let add3 = (x, y) => x+y;
console.log(add3(5, 6));

let add4 = function add5 (x, y) {
  return x+y
}
console.log(add4(7, 8));
// console.log(add5(7, 8)); // error

/**
 *    + 함수 add3 같은 경우 실제로 참조하는 두 수를 더하는 함수의 이름이 없다.
 *    + 이름이 없는 함수의 형태를 익명 함수라고 부른다.
 *    + 이것이 익명 함수를 이용한 함수 표현식 방법(익명 함수 표현식)이고 익명 함수의 호출은 변수에 함수 호출 연산자 ()를 붙여 가능하다.
 *    + 함수 이름이 포함된 함수 표현식을 기명 함수 표현식이라 하는데 주의해야 할 점이 있다.
 *    + add4, add5 같은 경우 add5로는 접근이 불가능 한다 함수 표현식에서 사용된 함수 이름이 외부 코드에서 접근 불가능하기 때문이다.
 *    + 함수 선언문 방식의 경우 내부적으로 함수 표현식으로 바꿔서 실행되기 때문에 접근 가능하다. ref) function add ... -> var add = function add ...
 *    + 함수 표현식에서는 함수 이름이 선택 사항이지만, 이런 함수 이름을 이용하면 함수 코드 내부에서 함수 이름으로 함수의 재귀적인 호출 처리가 가능하다.
 */

let add6 = function add7 (number) {
  if(number <= 1) {
    return 1;
  }

  return number*add7(number-1);
}

console.log(add6(5));

let func1 = function() {
  return 21;
}; // 여기에 세미콜론이 있어야한다.
(function() {
  console.log("func1 called");
})();

console.log(func1())
/**
 *    + 세미 콜론이 없으면 number is not a function 이라는 에러가 발생한다.
 *    + 이유는 자바스크립트 파서가 func1()의 함수 정의에서 세미콜론을 사용하지 않아 return 21; 문장을 지나 함수 끝에있는 } 만으로 함수가 끝났다고 판단하지 않기 때문이다.
 *    + 자바스크립트 파서는 이후에 괄호에 둘러싸여 정의된 즉시 실행 함수를 보고 이를 마치 func1() 함수 호출 연산으로 생각해서 func1()를 호출해버린다.
 *    + 그렇기 때문에 func() 함수가 호출되면 21가 반환되고 즉시 실행 함수를 실행하려고 남겨둔 마지막 () 괄호가 있으므로 21(); 형태로 또다시 함수를 호출하려고 시도한다.
 *    + 그러나 21는 숫자이지 함수가 아니므로 number is not a function 에러가 발생하게 되는 것이다.
 */

let func2 = function(f) {
  return f();
}
(function() {
  console.log("func2 called");
})//();

/**
 *  * Function() 생성자 함수를 통한 함수 생성
 *    + 자바스크립트의 함수도 Function() 이라는 기본 내장 생성자 함수로부터 생성된 객체라 볼 수 있다.
 *    + 앞의 함수 선언문, 함수 표현식 방식도 Function() 생성자 함수가 아닌 함수 리터럴 방식으로 함수를 생성하지만, 결국엔 내부적으로는 Function() 생성자 함수로 함수가 생성된다 볼 수 있다.
 *    + 하지만 일반적으로 Function() 생성자 함수를 사용한 함수 생성 밥법은 자주 사용되지 않는다.
 */

let add8 = new Function('x', 'y', 'return x+y');
console.log(add8(1, 2));

/**
 *  * 함수 호이스팅
 *    + 함수 선언 방식마다 동작 방식 차이가 약간씩 있는데 그중 하나가 함수 호이스팅이다.
 *    + 자바스크립트 Guru로 알려진 더글러스 크락포트는 함수 생성에 있어 함수 표현식을 권하고 있는데 그 이유 중의 하나가 함수 호이스팅 때문이다.
 *      - 함수 선언식은 함수를 사용하기 전에 반드시 선언해야 한다는 규칙을 무시하기 때문이다.
 */

add9(1, 2)
function add9 (x, y) {
  return console.log(x+y);
}
add9(3, 4)

// add10(1, 2) // error
let add10 = (x, y) => console.log(x+y);
add10(3, 4)

/**
 *    + 함수 호이스팅이 발생하는 원인은 자바스크립트의 변수 생성과 초기화의 작업이 분리돼서 진행되기 때문이다.
 */

