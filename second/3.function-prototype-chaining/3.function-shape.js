/**
 * # 함수의 다양한 형태
 *  
 *  * 콜백 함수
 *    + 자바스크립트 함수 표현식에서 함수 이름은 꼭 붙이지 않아도 되는 선택 사항 (익명 함수)
 *    + 이런 익명 함수의 대표적인 용도가 콜백 함수이다.
 *    + 콜백 함수는 명시적으로 호출하는게 아닌 등록만 하고 어떤 이벤트가 발생했을때 시스템에서 호출되는 함수를 말한다.
 *    + 또는 특정 함수의 인자로 넘겨서, 코드 내부에서 호출되는 함수 또한 콜백 함수이다. 
 *    + 대표적으로 이벤트 핸들러 처리이다.
 *      - 웹 페이지가 로드 되거나 키보드가 입력되는 등의 DOM 이벤트가 발생할 경우, 브라우저는 정의된 DOM 이벤트에 해당하는 이벤트 핸들러를 실행시킨다. 
 * 
 *  * 즉시 실행 함수
 *   + 함수를 정의함과 동시에 바로 실행
 */

((name) => {
  console.log(`this is ${name}`)
})('immediate functions')

/**
 *    + 즉시 실행 함수의 경우, 같은 함수를 다시 호출할 수 없다. 최초 한 번의 실행만을 필요로 하는 초기화 코드 부분 등에 사용할 수 있다.
 *    + 또는 자바스크립트 라이브러리나 프레임워크 소스들에서 사용된다.
 *      - 자바스크립트의 변수 유효 범위 특성 때문
 *      - 자바스크립트에서는 함수 유효 범위를 지원한다.
 *      - 기본적으로 자바스크립트는 변수를 선언할 경우 프로그램 전체에서 접근할 수 있는 전역 유효 범위를 가진다.
 *      - 그러나 함수 내부에서 정의된 매개변수와 변수들은 함수 코드 내부에서만 유효할 뿐 함수 밖에서는 유효하지 않다. (var, let, const가 아닌 아무것도 없이 정의하면 예외)
 *      - 달리 말하면 함수 외부에서 함수 내부의 변수를 엑세스하는 게 불가능하다.
 *      - 라이브러리 코드를 즉시 실행 함수 내에 정의해두면 라이브러리 내의 변수들은 함수 외부에서 접근할 수 없고, 즉시 실행 함수 내에 라이브러리 코드를 추가하면 전역 네임스페이스를 더럽히지 않는다.
 *      - 다른 자바스크립트 라이브러리들이 동시에 로드가 되더라도 라이브러리 간 변수 이름 출동 같은 문제를 방지할 수 있다. 
 * 
 *  * 내부 함수
 *    + 자바스크립트에서 함수 코드 내부에 다시 함수 정의가 가능하다.
 *    + 자바스크립트의 기능을 보다 강력하게 해주는 클로저를 생성하거나 부모 함수 코드에서 외부에서의 접근을 막고 독립적인 헬퍼 함수를 구현하는 용도 등으로 사용한다.
 */

let parent1 = () => {
  let a = 100;
  let b = 200;

  let child = () => {
    let b = 300;

    console.log(a);
    console.log(b);
  }

  child();
}

parent1();
// child(); // child is not defined

/**
 *    + 내부 함수에서는 자신을 둘러싼 부모 함수의 변수에 접근이 가능하다.
 *      - 자바스크립트의 스코프체이닝 덕분에 가능하다.
 *    + 내부 함수는 일반적으로 자신이 정의된 부모 함수 내부에서만 호출이 가능하다.
 *    + 함수 스코프(함수 블록) 밖에서 함수 스코프 안에 선언된 모둔 변수나 함수에 접근이 불가능하다.
 *    
 *    + 함부 외부에서도 특정 함수 스코프 안에 선언된 내부 함수를 호출할 수 있다.
 */

let parent2 = () => {
  let a = 100;
  let child = () => {
    console.log('child of parent2', a)
  }

  return child;
}

let inner1 = parent2();
inner1();
parent2()();

/**
 *    + parent2() 와 같은 부모 함수 스코프의 변수를 참조하는 inner1()와 같은 함수를 클로저라고 한다.
 * 
 *  * 함수를 리턴하는 함수
 *    + 자바스크립트에서는 함수도 일급 객체이므로 일반 값처럼 함수 자체를 리턴할 수 있고 다양한 활용이 가능하다.
 */

let self1 = () => {
  console.log('a');
  return () => {
    console.log('b');
  }
}

self1 = self1();
self1();
